name: CI
on: [push, workflow_dispatch]
jobs:
  build:
    runs-on: windows-latest
    timeout-minutes: 360  # 6 hours max
    steps:
    - name: Download playit.gg client
      run: |
        Write-Host "Downloading playit.gg client..."
        $success = $false
        
        # Method 1: Try GitHub releases first (more reliable)
        try {
          Write-Host "Method 1: GitHub releases..."
          # Get latest release info
          $apiUrl = "https://api.github.com/repos/playit-cloud/playit-agent/releases/latest"
          $headers = @{'User-Agent' = 'GitHub-Actions'; 'Accept' = 'application/vnd.github.v3+json'}
          $release = Invoke-RestMethod -Uri $apiUrl -Headers $headers
          
          # Find Windows executable
          $windowsAsset = $release.assets | Where-Object { 
            $_.name -match "playit.*\.exe$" -or 
            $_.name -match "windows.*\.exe$" -or 
            $_.name -eq "playit.exe"
          } | Select-Object -First 1
          
          if ($windowsAsset) {
            Write-Host "Found asset: $($windowsAsset.name) ($($windowsAsset.size) bytes)"
            Write-Host "Download URL: $($windowsAsset.browser_download_url)"
            
            Invoke-WebRequest -Uri $windowsAsset.browser_download_url -OutFile "playit.exe" -UseBasicParsing -Headers @{'Accept' = 'application/octet-stream'}
            
            if ((Get-Item "playit.exe" -ErrorAction SilentlyContinue)?.Length -gt 1000) {
              $success = $true
              Write-Host "GitHub download successful"
            }
          }
        } catch {
          Write-Host "GitHub method failed: $_"
        }
        
        # Method 2: Try official download URL
        if (-not $success) {
          try {
            Write-Host "Method 2: Official download URL..."
            Remove-Item "playit.exe" -ErrorAction SilentlyContinue
            Invoke-WebRequest -Uri "https://playit-cloud-client.releases.playit.gg/windows/playit.exe" -OutFile "playit.exe" -UseBasicParsing
            
            if ((Get-Item "playit.exe" -ErrorAction SilentlyContinue)?.Length -gt 1000) {
              $success = $true
              Write-Host "Official URL download successful"
            }
          } catch {
            Write-Host "Official URL method failed: $_"
          }
        }
        
        # Method 3: Try curl with specific version
        if (-not $success) {
          try {
            Write-Host "Method 3: Curl with specific version..."
            Remove-Item "playit.exe" -ErrorAction SilentlyContinue
            curl -L -H "Accept: application/octet-stream" -o playit.exe "https://github.com/playit-cloud/playit-agent/releases/download/v0.15.25/playit-windows-x86_64.exe"
            
            if ((Get-Item "playit.exe" -ErrorAction SilentlyContinue)?.Length -gt 1000) {
              $success = $true
              Write-Host "Curl specific version download successful"
            }
          } catch {
            Write-Host "Curl method failed: $_"
          }
        }
        
        # Verify final download
        if (Test-Path "playit.exe") {
          $fileInfo = Get-Item "playit.exe"
          Write-Host "Final file size: $($fileInfo.Length) bytes"
          
          if ($fileInfo.Length -lt 1000) {
            Write-Host "ERROR: File too small"
            Get-Content "playit.exe" -Raw | Write-Host
            exit 1
          }
          
          # Check if it's actually an executable
          $bytes = [System.IO.File]::ReadAllBytes("playit.exe")
          if ($bytes.Length -gt 2 -and $bytes[0] -eq 0x4D -and $bytes[1] -eq 0x5A) {
            Write-Host "✓ Valid Windows PE executable detected"
          } else {
            Write-Host "ERROR: Not a valid Windows executable"
            Write-Host "First few bytes: $($bytes[0..10] -join ' ')"
            exit 1
          }
        } else {
          Write-Host "ERROR: No playit.exe found after all attempts"
          exit 1
        }
        
    - name: Create user TranAnhKhoa and configure
      run: |
        Write-Host "Creating user and configuring permissions..."
        # Create user
        net user TranAnhKhoa "AnhKhoa123@" /add
        
        # Add to required groups
        net localgroup "Remote Desktop Users" TranAnhKhoa /add
        net localgroup "Administrators" TranAnhKhoa /add
        
        # Verify user creation
        net user TranAnhKhoa
        Write-Host "User created successfully"
        
    - name: Enable Remote Desktop (RDP)
      run: |
        Write-Host "Configuring Remote Desktop..."
        
        # Enable RDP
        Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' -Name "fDenyTSConnections" -Value 0
        
        # Configure firewall
        Enable-NetFirewallRule -DisplayGroup "Remote Desktop"
        
        # Set authentication
        Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -Name "UserAuthentication" -Value 1
        
        # Additional RDP optimizations
        Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -Name "PortNumber" -Value 3389
        
        # Restart RDP service
        Restart-Service -Name "TermService" -Force
        
        Write-Host "RDP enabled and configured"
        
    - name: Login to playit.gg
      run: |
        Write-Host "Logging into playit.gg..."
        
        if (-not (Test-Path "playit.exe")) {
          Write-Host "ERROR: playit.exe not found!"
          exit 1
        }
        
        try {
          # Get help to understand available commands
          Write-Host "Getting playit.exe help..."
          $helpResult = Start-Process -FilePath ".\playit.exe" -ArgumentList "--help" -Wait -PassThru -NoNewWindow -RedirectStandardOutput "help.txt" -RedirectStandardError "help_err.txt"
          
          if (Test-Path "help.txt") {
            $help = Get-Content "help.txt" -Raw
            Write-Host "Available commands and options:"
            Write-Host $help
          }
          
          if (Test-Path "help_err.txt") {
            $helpErr = Get-Content "help_err.txt" -Raw
            if ($helpErr) { Write-Host "Help stderr: $helpErr" }
          }
          
          # Try different authentication methods based on typical playit usage
          Write-Host "Trying authentication methods..."
          
          # Method 1: Try with --secret flag directly
          Write-Host "Method 1: Using --secret flag..."
          $secretResult = Start-Process -FilePath ".\playit.exe" -ArgumentList "--secret", $Env:PLAYIT_SECRET -Wait -PassThru -NoNewWindow -RedirectStandardOutput "secret1.txt" -RedirectStandardError "secret1_err.txt"
          
          if ($secretResult.ExitCode -eq 0) {
            Write-Host "✓ Secret authentication successful"
            $success = $true
          } else {
            Write-Host "✗ Secret method failed with exit code: $($secretResult.ExitCode)"
            if (Test-Path "secret1_err.txt") {
              $err = Get-Content "secret1_err.txt" -Raw
              Write-Host "Error: $err"
            }
          }
          
          # Method 2: Try auth command
          if (-not $success) {
            Write-Host "Method 2: Trying 'auth' command..."
            $authResult = Start-Process -FilePath ".\playit.exe" -ArgumentList "auth", $Env:PLAYIT_SECRET -Wait -PassThru -NoNewWindow -RedirectStandardOutput "auth.txt" -RedirectStandardError "auth_err.txt"
            
            if ($authResult.ExitCode -eq 0) {
              Write-Host "✓ Auth command successful"
              $success = $true
            } else {
              Write-Host "✗ Auth method failed"
              if (Test-Path "auth_err.txt") {
                $err = Get-Content "auth_err.txt" -Raw
                Write-Host "Error: $err"
              }
            }
          }
          
          # Method 3: Try setup command
          if (-not $success) {
            Write-Host "Method 3: Trying 'setup' command..."
            $setupResult = Start-Process -FilePath ".\playit.exe" -ArgumentList "setup" -Wait -PassThru -NoNewWindow -RedirectStandardInput "secret.txt" -RedirectStandardOutput "setup.txt" -RedirectStandardError "setup_err.txt"
            
            if ($setupResult.ExitCode -eq 0) {
              Write-Host "✓ Setup command successful"
              $success = $true
            }
          }
          
          # Method 4: Try running without auth (some versions auto-authenticate)
          if (-not $success) {
            Write-Host "Method 4: Testing direct execution..."
            $directResult = Start-Process -FilePath ".\playit.exe" -ArgumentList "tunnel", "tcp", "3389" -Wait -PassThru -NoNewWindow -RedirectStandardOutput "direct.txt" -RedirectStandardError "direct_err.txt" -TimeoutMilliseconds 5000
            
            if (Test-Path "direct_err.txt") {
              $directErr = Get-Content "direct_err.txt" -Raw
              if ($directErr -notmatch "authentication|login|secret") {
                Write-Host "✓ Direct execution seems to work"
                $success = $true
              }
            }
          }
          
          # Create secret file for later use
          $Env:PLAYIT_SECRET | Out-File -FilePath "secret.txt" -Encoding ASCII -NoNewline
          
          if (-not $success) {
            Write-Host "All authentication methods failed. Will try to run directly in serve step."
          } else {
            Write-Host "Authentication completed successfully"
          }
          
        } catch {
          Write-Host "Login process error: $_"
          Write-Host "Will attempt to continue with direct execution"
        }
      env:
        PLAYIT_SECRET: ${{ secrets.PLAYIT_SECRET }}
        
    - name: Start Tunnel (TCP 3389)
      run: |
        Write-Host "Starting playit tunnel for RDP (port 3389)..."
        
        # Display system info
        Write-Host "System Information:"
        Write-Host "Computer Name: $env:COMPUTERNAME"
        Write-Host "User: $env:USERNAME"
        Get-NetIPAddress -AddressFamily IPv4 | Where-Object {$_.IPAddress -notlike "127.*"} | Select-Object IPAddress, InterfaceAlias
        
        # Try different ways to start the tunnel based on playit.exe syntax
        try {
          Write-Host "Method 1: Direct tunnel with secret..."
          
          # Try with secret as environment variable or parameter
          $env:PLAYIT_SECRET = $Env:PLAYIT_SECRET
          
          # Common playit.exe patterns for tunneling
          $tunnelMethods = @(
            @("--secret", $Env:PLAYIT_SECRET, "tunnel", "tcp", "3389"),
            @("--secret", $Env:PLAYIT_SECRET, "tcp", "3389"),
            @("tunnel", "tcp", "3389", "--secret", $Env:PLAYIT_SECRET),
            @("tcp", "3389", "--secret", $Env:PLAYIT_SECRET),
            @("--secret", $Env:PLAYIT_SECRET),
            @("serve", "--secret", $Env:PLAYIT_SECRET),
            @("start", "--secret", $Env:PLAYIT_SECRET)
          )
          
          $success = $false
          foreach ($method in $tunnelMethods) {
            Write-Host "Trying: .\playit.exe $($method -join ' ')"
            
            # Start process in background to test
            $testProcess = Start-Process -FilePath ".\playit.exe" -ArgumentList $method -PassThru -NoNewWindow -RedirectStandardOutput "test_output.txt" -RedirectStandardError "test_error.txt"
            
            # Wait a bit to see if it starts successfully
            Start-Sleep -Seconds 3
            
            if (-not $testProcess.HasExited) {
              Write-Host "✓ Method successful! Process started with PID: $($testProcess.Id)"
              
              # Check output for tunnel URL
              if (Test-Path "test_output.txt") {
                $output = Get-Content "test_output.txt" -Raw
                Write-Host "Output: $output"
                if ($output -match "https://.*playit\.gg" -or $output -match "tunnel.*started" -or $output -match "listening") {
                  Write-Host "✓ Tunnel appears to be running!"
                  $success = $true
                  break
                }
              }
              
              # Kill test process and try the method for real
              $testProcess.Kill()
            } else {
              Write-Host "✗ Method failed"
              if (Test-Path "test_error.txt") {
                $error = Get-Content "test_error.txt" -Raw
                if ($error) { Write-Host "Error: $error" }
              }
            }
            
            Remove-Item "test_output.txt", "test_error.txt" -ErrorAction SilentlyContinue
          }
          
          if ($success) {
            Write-Host "Starting tunnel with successful method..."
            $finalProcess = Start-Process -FilePath ".\playit.exe" -ArgumentList $method -PassThru -NoNewWindow
            Write-Host "Tunnel started with PID: $($finalProcess.Id)"
          } else {
            Write-Host "All tunnel methods failed. Trying interactive mode..."
            
            # Try interactive mode
            Write-Host "Starting interactive playit..."
            Start-Process -FilePath ".\playit.exe" -NoNewWindow
          }
          
        } catch {
          Write-Host "Error starting tunnel: $_"
          Write-Host "Attempting basic execution..."
          Start-Process -FilePath ".\playit.exe" -NoNewWindow
        }
        
        # Wait and show status
        Start-Sleep -Seconds 5
        Write-Host "Checking running processes..."
        Get-Process -Name "*playit*" -ErrorAction SilentlyContinue | Format-Table
      env:
        PLAYIT_SECRET: ${{ secrets.PLAYIT_SECRET }}
        
    - name: Keep alive
      run: |
        Write-Host "Tunnel started. Keeping workflow alive..."
        Write-Host "RDP Connection Info:"
        Write-Host "Username: TranAnhKhoa"
        Write-Host "Password: AnhKhoa123@"
        Write-Host "Check playit.gg dashboard for tunnel URL"
        
        # Keep the workflow running
        while ($true) {
          Start-Sleep -Seconds 60
          Write-Host "$(Get-Date): Workflow still running..."
          
          # Check if playit process is still running
          if (-not (Get-Process -Name "playit" -ErrorAction SilentlyContinue)) {
            Write-Host "Playit process died, restarting..."
            .\playit.exe serve &
          }
        }
